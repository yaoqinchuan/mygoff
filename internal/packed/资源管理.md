# 资源管理

## 1、工具打包

​		我们可以通过gf命令行工具的pack命令实现对任意文件/目录的打包，关于gf命令行工具的安装和使用。由于通过命令行工具进行打包比较简便，因此也是推荐的打包方式。

### 1.2、gf pack生成Go文件

​		比较推荐的方式是将Go文件直接生成到boot启动目录，并设置生成Go文件的包名为boot，这样该资源文件将会被自动引入到项目中。我们将项目的config,public,template三个目录的文件打包到Go文件，打包命令为：

```shell
gf pack config,public,template packed/data.go -n packed
```

​		生成的Go文件内容类似于：

```go
package packed

import "github.com/gogf/gf/v2/os/gres"

func init() {
	if err := gres.Add("H4sIAAAAAAAC/5y8c5Bl0Zbuu9O2bVaq0rZZ6Urbtm3bNnfatipto9"); err != nil {
		panic(err)
	}
}
```

​		可以看到，生成的Go文件中通过gres.Add方法将资源文件的二进制内容添加到默认的资源管理器中，该方法的参数是压缩过后的BASE64字符串，将会在程序启动的时候做解压并在内存中生成一个文件树对象，便于在运行时快速操作文件。

### 1.3、使用打包的Go文件

#### **1.3.1、在boot包中优先引入packed资源包**

​		在项目的boot程序启动设置包中自动引入packed资源包，并且应当作为第一个引入的包，以便于其他引入的包在初始化时（init方法中）便能使用到资源内容，例如像这样（module名称为my-app）：

```go
import (
    _ "my-app/packed"

    // 其他包

)
```

​		 这里建议引入`packed`包和其他包之间加入一个空行以作区分，特别是`Goland` IDE的`import`插件不会将引入包进行自动排序。 

#### 1.3.2、在main包中优先引入boot包

​		由于项目的main入口程序文件会引入boot包，并且应当作为第一个引入的包：

```go
import (
    _ "my-app/boot"

    // 其他包

)
```

​		这里建议引入boot包和其他包之间加入一个空行以作区分，特别是Goland IDE的import插件不会将引入包进行自动排序。随后可以在项目的任何地方使用gres模块来访问打包的资源文件。

​		如果使用GoFrame推荐的项目目录结构（新建项目），在目录结构中会存在boot目录（对应包名也是boot），用于程序启动设置。因此如果将Go文件生成到boot目录下，那么将会被自动编译进可执行文件中。

#### 1.3.3、打印资源管理文件列表

​		可以通过gres.Dump()方法打印出当前资源管理器中所有的文件列表，输出内容类似于：2019-09-15T13:36:28+00:00   0.00B config

```
2019-07-27T07:26:12+00:00   1.34K config/config.toml
2019-09-15T13:36:28+00:00   0.00B public
2019-06-25T17:03:56+00:00   0.00B public/resource
2018-12-04T12:50:16+00:00   0.00B public/resource/css
2018-12-17T12:54:26+00:00   0.00B public/resource/css/document
2018-12-17T12:54:26+00:00   4.20K public/resource/css/document/style.css
2018-08-24T01:46:58+00:00  32.00B public/resource/css/index.css
2019-05-23T03:51:24+00:00   0.00B public/resource/image
2018-08-20T05:02:08+00:00  24.01K public/resource/image/cover.png
2019-05-23T03:51:24+00:00   4.19K public/resource/image/favicon.ico
2018-08-23T01:44:50+00:00   4.19K public/resource/image/gf.ico
2018-12-04T13:04:34+00:00   0.00B public/resource/js
2019-06-27T11:06:12+00:00   0.00B public/resource/js/document
2019-06-27T11:06:12+00:00  11.67K public/resource/js/document/index.js
2019-09-15T13:36:28+00:00   0.00B template
2019-02-02T09:08:56+00:00   0.00B template/document
2018-12-04T12:49:08+00:00   0.00B template/document/include
2018-12-04T12:49:08+00:00 329.00B template/document/include/404.html
2019-03-06T01:52:56+00:00   3.42K template/document/index.html
...
```

需要注意的是，在使用资源管理器中的资源文件时，需要严格按照其路径进行检索获取。

## 2、方法打包

​		我们介绍资源管理中涉及到的方法，并通过一个打包/解包二进制资源文件的示例，介绍这些方法实现自定义的打包/解包功能。同时，我们也演示了如何通过自定义加解密来保护我们的资源文件内容。

- 通过Pack*/Unpack*方法可以实现对任意文件的打包/解包功能，可以打包到二进制文件或者Go代码文件。
- 资源管理由Resource对象实现，可实现对打包内容的添加，文件的检索查找，以及对目录的遍历等功能。
- 资源文件由File对象实现，该文件对象和os.File文件对象类似，并且该对象实现了http.File接口。
- ScanDir用于针对于特定目录下的文件/目录检索，并且支持递归检索。
- ScanDirFile用于针对于特定目录下的文件检索，并且支持递归检索。
- 通过Dump方法在终端打印出Resource资源对象所有的文件列表，资源管理器中的文件分隔符号统一为/。
  此外，gres资源管理模块提供了默认的Resource对象，并通过包方法提供了对该默认对象的操作。

### 2.1、自定义打包示例

​		我们将项目根目录下的public和config目录打包为data.bin二进制文件，并通过gaes加密算法对生成的二进制内容进行加密。

```go
package main

import (
	"github.com/gogf/gf/v2/crypto/gaes"
	"github.com/gogf/gf/v2/os/gfile"
	"github.com/gogf/gf/v2/os/gres"
)

var (
	CryptoKey = []byte("x76cgqt36i9c863bzmotuf8626dxiwu0")
)

func main() {
	binContent, err := gres.Pack("public,config")
	if err != nil {
		panic(err)
	}
	binContent, err = gaes.Encrypt(binContent, CryptoKey)
	if err != nil {
		panic(err)
	}
	if err := gfile.PutBytes("data.bin", binContent); err != nil {
		panic(err)
	}
}
```

### 2.2、自定义解包示例

​		我们使用将刚才打包生成的data.bin，需要解密和解包两步操作。

```go
package main

import (
	"github.com/gogf/gf/v2/crypto/gaes"
	"github.com/gogf/gf/v2/os/gfile"
	"github.com/gogf/gf/v2/os/gres"
)

var (
	CryptoKey = []byte("x76cgqt36i9c863bzmotuf8626dxiwu0")
)

func main() {
	binContent := gfile.GetBytes("data.bin")
	binContent, err := gaes.Decrypt(binContent, CryptoKey)
	if err != nil {
		panic(err)
	}
	if err := gres.Add(binContent); err != nil {
		panic(err)
	}
	gres.Dump()
}
```

最后，我们使用gres.Dump()打印出添加成功的文件列表查看资源文件是否添加成功。

## 3、方法介绍

### 3.1、Add

- 说明：Add将content解压并添加到默认资源对象。prefix是非必要参数，表示存储到当前资源对象中的每个文

  件的前缀。  

- 格式：

  ```go
  func Add(content string, prefix ...string) error
  ```

- 实例：

```GO
package main

import "github.com/gogf/gf/v2/os/gres"

func main() {
	if err := gres.Add("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"); err != nil {
		panic("add binary content to resource manager failed: " + err.Error())
	}
}
```

### 3.2、Load

- 说明：`Load`加载、解压并将路径为`path`的文件数据读取到默认资源对象中。`prefix`是非必要参数，表示存储到当前资源对象中的每个文件的前缀。  

- 格式：

  

  ```go
  func Load(path string, prefix ...string) error
  ```

- 示例：

```go
package main

import "github.com/gogf/gf/v2/os/gres"

func main() {
	if err := gres.Load("../res/myfile"); err != nil {
		panic("load binary content to resource manager failed: " + err.Error())
	}
}
```

### 3.3、Get

- 说明：Get返回指定路径的文件。

- 格式：


```go
func Get(path string) *File
```

- 
  示例：

```go
package main

import (
	"fmt"
	"github.com/gogf/gf/v2/os/gctx"
	"github.com/gogf/gf/v2/os/glog"
	"github.com/gogf/gf/v2/os/gres"
)

func main() {
	file := gres.Get("../res/myfile")
	if file == nil {
		glog.Error(gctx.New(), "get file failed!")
		return
	}

	fmt.Println("Get File Name:", file.Name())

}
```

### 3.4、GetWithIndex

- 说明：GetWithIndex用给定路径path搜索文件，如果文件是目录，那么它会在这个目录下进行索引文件搜索。 GetWithIndex通常用于http静态文件服务。  

- 格式：


```go
func GetWithIndex(path string, indexFiles []string) *File
```

- 
  示例：

```go
package main

import (
	"fmt"
	"github.com/gogf/gf/v2/os/gctx"
	"github.com/gogf/gf/v2/os/glog"
	"github.com/gogf/gf/v2/os/gres"
)

func main() {
	file := gres.GetWithIndex("../res", []string{"myfile", "myconfig"})
	if file == nil {
		glog.Error(gctx.New(), "get file failed!")
		return
	}

	fmt.Println("Get File Name:", file.Name())

}
```

### 3.5、GetContent

- 说明：GetContent在默认资源对象中直接返回路径为path的内容。  

- 格式：


```go
func GetContent(path string) []byte
```

- 
  示例：

```go
package main

import (
	"fmt"
	"github.com/gogf/gf/v2/os/gres"
)

func main() {
	fileContent := gres.GetContent("../res/myfile")
	fmt.Println("Get File Content:", fileContent)
}
```

### 3.6、Contains

- 说明：Contains检查路径为path的资源是否存在于默认资源对象中。  

- 格式：


```go
func Contains(path string) bool
```

- 
  示例：

```go
package main

import (
	"fmt"
	"github.com/gogf/gf/v2/os/gres"
)

func main() {
	if gres.Contains("../res/myfile") {
		fmt.Println("myfile is exist!")
	} else{
		fmt.Println("myfile is not exist!")
	}

}
```

### 3.7、ScanDir

- 说明：ScanDir返回给定路径下的文件，参数path应该是文件夹类型。参数pattern支持多个文件名模式，使用，符号分隔多个模式。如果参数recursive为true，它会递归地扫描目录。  

- 格式：


```go
func ScanDir(path string, pattern string, recursive ...bool) []*File
```

- 
  示例：

```go
package main

import (
	"fmt"
	"github.com/gogf/gf/v2/os/gres"
)

func main() {
	files := gres.ScanDir("../res", "*.doc,*.go", true)
	if len(files) > 0 {
		for _, file := range files {
			fmt.Println("ScanDir Result:", file.Name())
		}
	}
}
```

### 3.8、ScanDirFile

- 说明：ScanDirFile返回所有具有给定path的绝对路径的子文件，如果参数recursive为true，则会递归扫描目录。  注意：只返回文件，不返回目录。  
- 格式：

```go
func ScanDirFile(path string, pattern string, recursive ...bool) []*File
```

-  示例：

```go
package main

import (
	"fmt"
	"github.com/gogf/gf/v2/os/gres"
)

func main() {
	files := gres.ScanDirFile("../res", "*.*", true)
	if len(files) > 0 {
		for _, file := range files {
			fmt.Println("ScanDirFile Result:", file.Name())
		}
	}
}
```

### 3.9、Export

- 说明：Export将指定路径src及其所有子文件递归保存到指定的系统路径dst。  

- 格式：


```go
func Export(src, dst string, option ...ExportOption) error
```

- 
  示例：

```go
package main

import (
	"fmt"
	"github.com/gogf/gf/v2/os/gres"
)

func main() {
	err := gres.Export("../res/src", "../res/dst")
	if err != nil {
		fmt.Println("gres.Export Error:", err)
	}
}
```

### 3.10、Dump

- 说明：Dump打印默认资源对象的文件。  

- 格式：


```go
func Dump()
```

- 
  示例：

```go
package main

import (
	"github.com/gogf/gf/v2/os/gres"
)

func main() {
	gres.Add("xxxxxxxxx")

	gres.Dump()

}
```

## 4、使用示例

​		我们来看一个使用示例，在该示例中，展示了资源管理在WebServer的静态服务、配置管理、模板引擎中的使用。

### 4.1、资源文件列表

三个文件的内容分别为：

1. config.toml


```go
 [server]
     Address    = ":8888"
     ServerRoot = "public"

 [viewer]
     DefaultFile = "index.tpl"
     Delimiters  = ["${", "}"]
```


该文件为应用的配置文件。

2、index.html

```
 Hello!
```


该文件用于静态资源请求。

3、index.tpl

```
 Hello ${.name}!
```


该文件用于模板文件解析展示。

### 4.2、创建应用

```go
package main

import (
	_ "github.com/gogf/gf/v2/os/gres/testdata/example/boot"

	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/net/ghttp"

)

func main() {
	s := g.Server()
	s.Group("/", func(group *ghttp.RouterGroup) {
		group.GET("/template", func(r *ghttp.Request) {
			r.Response.WriteTplDefault(g.Map{
				"name": "GoFrame",
			})
		})
	})
	s.Run()
}
```

​		可以看到，整个代码中除了import中额外增加了一个 _ "github.com/gogf/gf/v2/os/gres/testdata/example/boot" 的包引入外，没有其他任何设置。这也是GoFrame框架的资源管理比较便捷的地方，资源管理并不需要开发阶段对代码做任何特殊设置，在应用程序部署之前打包好资源文件，并通过import增加资源文件的引入即可。

运行后，终端输出：

```
2020-03-28 21:36:19.828 75892: http server started listening on [:8888]

  SERVER  | DOMAIN  | ADDRESS | METHOD |   ROUTE   |      HANDLER      | MIDDLEWARE
|---------|---------|---------|--------|-----------|-------------------|------------|
  default | default | :8888   | GET    | /template | main.main.func1.1 |
|---------|---------|---------|--------|-----------|-------------------|------------|
```

可以看到，配置文件被自动读取并应用到了WebServer上。

我们通过curl命令测试一下静态文件以及模板引擎的访问。

```go
$ curl http://127.0.0.1:8888/
Hello!

$ curl http://127.0.0.1:8888/template
Hello GoFrame!
```


可以看到，index.html静态文件以及index.tpl模板文件都被成功访问到了。

## 5、最佳实践

​		资源管理设计的目标之一是在开发阶段不影响静态文件的开发管理，只有在发布的时候执行打包即可，打包完毕后清理临时文件，因此只会影响生成的二进制可执行文件，对开发者来说无感知且使用便捷。

### 5.1、准备工程

​		建议大家使用GoFrame官方提供的工程化目录结构，并且使用CLI工具来创建自己的项目工程，因为整个框架工程化思想以及一些示例都是基于标准化的工程目录结构，这样更有利于大家学习和使用整个开发框架，提高开发效率。特别是，在工程目录中存在一个packed目录，用以存放资源管理组件的相关打包内容，在默认情况下，里面是一个空的go文件，什么都不会做。

<img src="C:\Users\yqc\Desktop\image2022-1-25_23-43-18 (1).png" style="zoom:60%;" />

### 5.2、开发阶段

​		在开发阶段，一般来说，开发者并不需要关心资源管理的事情，该怎么撸码就怎么撸，静态的文件按照建议放到public目录下。在开发阶段的静态文件访问都会直接通过文件系统访问。

### 5.3、准备发布

​			当开发完毕后，想要将静态文件、模板文件、模板文件、配置文件打包到二进制可执行文件中，随着二进制可执行文件发布。好的，这个时候资源组件开始介入展示能力了。您需要配置到交叉编译的配置，具体请参考命令行相关章节 交叉编译-build 。我们需要使用到CLI工具来执行可执行文件编译，将您的编译配置通过配置文件管理起来（放到config.yaml文件中），一个参考的编译配置如下：

```yaml
gfcli:
  build:
    name:      "my-application"
    arch:      "amd64"
    system:    "linux"
    mod:       "none"
    cgo:       0
    pack:      "config,i18n,public,template"
    version:   ""
    output:    "./bin"
    extra:     ""
```

​		请注意其中的pack配置，表示我们在执行编译的时候自动打包到二进制可执行文件中的目录。随后，我们在项目根目录下执行编译命令：

```go
gf build
```


​		该命令在编译时会自动将配置文件中指定的目录进行打包成临时的打包go文件，再执行编译，编译完毕后自动清理临时的打包go文件。

大部分场景下，配置文件可能不需要打包进二进制可执行文件，具体根据您的业务场景自行选择。

### 5.4、发布运行

将二进制执行发布执行即可。

## 6、I18N国际化

作为框架的核心组件之一，传承goframe一贯的便捷化设计思想，I18N国际化组件的配置管理非常简便。

### 6.1、文件格式

​		gi18n国际化组件支持框架通用的五种配置文件格式：xml/ini/yaml/toml/json（更详细的文件支持列表具体以配置管理章节为主：配置管理）。同样的，和配置管理模块一样，框架推荐使用toml文件格式。

### 6.2、读取路径

​		默认情况下gi18n会自动读取当前项目源码根目录（或者当前PWD运行目录下）下的i18n目录，默认将该目录作为国际化转译文件存储目录。开发者也可以通过SetPath方法自定义i18n文件的存储目录路径。

### 6.3、文件存储

​		在i18n目录下可以直接按照国际化名称命名的文件如：en.toml/ja.toml/zh-CN.toml；也可以给定国际化名称目录，目录下随意自定义配置文件，如：en/editor.toml/en/user.toml、zh-CN/editor.toml/zh-CN/user.toml。您使用纯文件管理或者增加一级目录管理都是可以的，gi18n可以智能识别加载。

例如，以下的i18n目录结构以及文件格式都是支持的。

通过单独的i18n文件区分不同的语言

```
└── i18n
    ├── en.toml
    ├── ja.toml
    ├── ru.toml
    ├── zh-CN.toml
    └── zh-TW.toml
```


通过不同的目录名称区分不同的语言

```yaml
└── i18n
    ├── en
    │   ├── hello.toml
    │   └── world.toml
    ├── ja
    │   ├── hello.yaml
    │   └── world.yaml
    ├── ru
    │   ├── hello.ini
    │   └── world.ini
    ├── zh-CN
    │   ├── hello.json
    │   └── world.json
    └── zh-TW
        ├── hello.xml
        └── world.xml
```


不同语言可以存在不同文件格式

```yaml
└── i18n
    ├── en.toml
    ├── ja.yaml
    ├── ru.ini
    ├── zh-CN.json
    └── zh-TW.xml
```

### 6.4、资源管理器

​		gi18n默认支持资源管理器（详情请参考章节：资源管理），默认情况下会从gres配置管理器中检索i18n目录，或者开发者设置的i18n目录路径。