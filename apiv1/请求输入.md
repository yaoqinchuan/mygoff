# 请求输入

## 1、简介

### 1.1、传统参数获取方法

可以看到Request对象的参数获取方法非常丰富，可以分为以下几类：

1. Get*: 常用方法，简化参数获取，GetRequest*的别名。

2. GetQuery*: 获取GET方式传递过来的参数，包括Query String及Body参数解析。*

3. *GetForm*: 获取表单方式传递过来的参数，表单方式提交的参数Content-Type往往为application/x-www-form-urlencoded, application/form-data, multipart/form-data, multipart/mixed等等。
4. GetRequest*: 获取客户端提交的参数，不区分提交方式。*

5. *Get*Struct: 将指定类型的请求参数绑定到指定的struct对象上，注意给定的参数为对象指针。绝大部分场景中往往使用Parse方法将请求数据转换为请求对象，具体详见后续章节。
6. GetBody/GetBodyString: 获取客户端提交的原始数据，该数据是客户端写入到body中的原始数据，与HTTP Method无关，例如客户端提交JSON/XML数据格式时可以通过该方法获取原始的提交数据。
7. GetJson: 自动将原始请求信息解析为gjson.Json对象指针返回，gjson.Json对象具体在 通用编解码-gjson 章节中介绍。
8. Exit*: 用于请求流程退出控制，详见本章后续说明

### 1.2、提交方式

GoFrame框架的参数获取不是通过HTTP Method来做区分，而是通过参数提交类型来区分。例如，分别通过HTTP Method: POST、INPUT、DELETE来提交表单参数，在服务端获取参数不是通过GetPost/GetInput/GetDelete的方式来获取，而是统一通过GetForm方法来获取表单参数，针对其他的HTTP Method也是如此。

1. 在GoFrame框架下，有以下几种提交类型：

2. Router: 路由参数，来源于路由规则匹配。
3. Query: URL中的Query String参数解析，如：http://127.0.0.1/index?id=1&name=john 中的id=1&name=john。
4. Form: 表单提交参数，最常见的提交方式，提交的Content-Type往往为：application/x-www-form-urlencoded、multipart/form-data、multipart/mixed。
5. Body: 原始提交内容，从Body中获取并解析得到的参数，JSON/XML请求往往使用这种方式提交。

## 2、一般参数获取

使用Get方法，不做赘述

## 3、对象参数获取

 对象转换在请求处理中非常常见。我们推荐将输入和输出定义为`struct`结构体对象，以便于结构化的参数输入输出维护。`GoFrame`框架支持非常便捷的对象转换，支持将客户端提交的参数如`Query`参数、表单参数、内容参数、`JSON/XML`等参数非常便捷地转换为指定的`struct`结构体，并且支持提交参数与`struct`属性的映射关系维护。 

### **3.1、默认规则**

客户端提交的参数如果需要映射到服务端定义的`struct`属性上，可以采用默认的映射关系，这一点非常方便。默认的转换规则如下：

1. `struct`中需要匹配的属性必须为**`公开属性`**(首字母大写)。
2. 参数名称会自动按照 **`不区分大小写`** 且 **忽略`-/_/空格`符号** 的形式与`struct`属性进行匹配。
3. 如果匹配成功，那么将键值赋值给属性，如果无法匹配，那么忽略该键值。

### 3.2、自定义规则

自定义的参数映射规则可以通过为`struct`属性绑定`tag`实现，`tag`名称可以为`p/param/params`。例如：

```go
type User struct{
    Id    int
    Name  string
    Pass1 string `p:"password1"`
    Pass2 string `p:"password2"`
}
```

 其中我们使用了`p`标签来指定该属性绑定的参数名称。`password1`参数将会映射到`Pass1`属性，`password2`将会映射到`Pass2`属性上。其他属性采用默认的转换规则即可，无需设置`tag`。 

### 3.3、Parse转换

从v1.11版本开始，我们推荐使用Parse方法来实现struct的转换，该方法是一个便捷方法，内部会自动进行转换及数据校验，但如果struct中没有校验tag的绑定将不会执行校验逻辑。

使用示例：

```go
package main

import (
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/net/ghttp"
)

type RegisterReq struct {
	Name  string
	Pass  string `p:"password1"`
	Pass2 string `p:"password2"`
}

type RegisterRes struct {
	Code  int         `json:"code"`
	Error string      `json:"error"`
	Data  interface{} `json:"data"`
}

func main() {
	s := g.Server()
	s.BindHandler("/register", func(r *ghttp.Request) {
		var req *RegisterReq
		if err := r.Parse(&req); err != nil {
			r.Response.WriteJsonExit(RegisterRes{
				Code:  1,
				Error: err.Error(),
			})
		}
		// ...
		r.Response.WriteJsonExit(RegisterRes{
			Data: req,
		})
	})
	s.SetPort(8199)
	s.Run()
}
```

在该示例中，我们定义了两个结构体：`RegisterReq`用于参数接收，`RegisterRes`用于数据返回。

其中，我们使用`r.Parse(&req)`将客户端提交的参数转换为`RegisterReq`对象，当转换成功时`req`变量将会被初始化赋值（默认情况下为`nil`），否则该方法返回`err`并且`req`变量为`nil`。返回数据结构通过`RegisterRes`定义，并且返回格式为`JSON`，通过`r.Response.WriteJsonExit`实现，该方法将`RegisterRes`根据其内部定义的`json`标签转换为`JSON`格式并退出当前服务方法，不再执行该服务方法的后续逻辑。

## 4、请求校验

 `Request`对象支持非常完美的请求校验能力，通过给结构体属性绑定`v`标签即可。由于底层校验功能通过`gvalid`模块实现 

```go
package main

import (
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/net/ghttp"
)

// 注册请求数据结构
type RegisterReq struct {
	Name  string `p:"username"  v:"required|length:4,30#请输入账号|账号长度为:min到:max位"`
	Pass  string `p:"password1" v:"required|length:6,30#请输入密码|密码长度不够"`
	Pass2 string `p:"password2" v:"required|length:6,30|same:password1#请确认密码|密码长度不够|两次密码不一致"`
}

// 注册返回数据结构
type RegisterRes struct {
	Code  int         `json:"code"`
	Error string      `json:"error"`
	Data  interface{} `json:"data"`
}

func main() {
	s := g.Server()
	s.Group("/", func(group *ghttp.RouterGroup) {
		group.ALL("/register", func(r *ghttp.Request) {
			var req *RegisterReq
			if err := r.Parse(&req); err != nil {
				r.Response.WriteJsonExit(RegisterRes{
					Code:  1,
					Error: err.Error(),
				})
			}
			// ...
			r.Response.WriteJsonExit(RegisterRes{
				Data: req,
			})
		})
	})
	s.SetPort(8199)
	s.Run()
}
```

 在该示例中，我们定义了两个结构体：`RegisterReq`用于参数接收，`RegisterRes`用于数据返回。由于该接口返回的是`JSON`数据结构，可以看到，只有返回的结构体中存在`json`标签，而接收的结构体中只有`p`标签。因为`RegisterReq`仅用于参数接收，无需设置返回的`json`标签。 

### 4.1、校验错误处理

 可以看到在以上示例中，当请求校验错误时，所有校验失败的错误都返回了，这样对于用户体验不是特别友好。当产生错误时，我们可以将校验错误转换为`gvalid.Error`接口对象，随后可以通过灵活的方法控制错误的返回。 

```go
package main

import (
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/net/ghttp"
	"github.com/gogf/gf/v2/util/gvalid"
)

type RegisterReq struct {
	Name  string `p:"username"  v:"required|length:4,30#请输入账号|账号长度为:min到:max位"`
	Pass  string `p:"password1" v:"required|length:6,30#请输入密码|密码长度不够"`
	Pass2 string `p:"password2" v:"required|length:6,30|same:password1#请确认密码|密码长度不够|两次密码不一致"`
}

type RegisterRes struct {
	Code  int         `json:"code"`
	Error string      `json:"error"`
	Data  interface{} `json:"data"`
}

func main() {
	s := g.Server()
	s.Group("/", func(group *ghttp.RouterGroup) {
		group.ALL("/register", func(r *ghttp.Request) {
			var req *RegisterReq
			if err := r.Parse(&req); err != nil {
				// Validation error.
				if v, ok := err.(gvalid.Error); ok {
					r.Response.WriteJsonExit(RegisterRes{
						Code:  1,
						Error: v.FirstString(),
					})
				}
				// Other error.
				r.Response.WriteJsonExit(RegisterRes{
					Code:  1,
					Error: err.Error(),
				})
			}
			// ...
			r.Response.WriteJsonExit(RegisterRes{
				Data: req,
			})
		})
	})
	s.SetPort(8199)
	s.Run()
}
```

 可以看到，当错误产生后，我们可以通过`err.(gvalid.Error)`断言的方式判断错误是否为校验错误，如果是的话则返回第一条校验错误，而不是所有都返回。 



## 5、Context

 请求流程往往会在上下文中共享一些自定义设置的变量，例如在请求开始之前通过中间件设置一些变量，随后在路由服务方法中可以获取该变量并相应对一些处理。这种需求非常常见。在`GoFrame`框架中，我们推荐使用`Context`上下文对象来处理流程共享的上下文变量，甚至将该对象进一步传递到依赖的各个模块方法中。该`Context`对象类型实现了标准库的`context.Context`接口，该接口往往会作为模块间调用方法的第一个参数，该接口参数也是`Golang`官方推荐的在模块间传递上下文变量的推荐方式。 

```go
func (r *Request) GetCtx() context.Context
func (r *Request) SetCtx(ctx context.Context)
func (r *Request) GetCtxVar(key interface{}, def ...interface{}) *gvar.Var
func (r *Request) SetCtxVar(key interface{}, value interface{})
```

**简要说明：**

1. `GetCtx`方法用于获取当前的`context.Context`对象，作用同`Context`方法。
2. `SetCtx`方法用于设置自定义的`context.Context`上下文对象。
3. `GetCtxVar`方法用于获取上下文变量，并可给定当该变量不存在时的默认值。
4. `SetCtxVar`方法用于设置上下文变量。

```
package main

import (
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/net/ghttp"
)

const (
	TraceIdName = "trace-id"
)

func main() {
	s := g.Server()
	s.Group("/", func(group *ghttp.RouterGroup) {
		group.Middleware(func(r *ghttp.Request) {
			r.SetCtxVar(TraceIdName, "HBm876TFCde435Tgf")
			r.Middleware.Next()
		})
		group.ALL("/", func(r *ghttp.Request) {
			r.Response.Write(r.GetCtxVar(TraceIdName))
		})
	})
	s.SetPort(8199)
	s.Run()
}
```

 可以看到，我们可以通过`SetCtxVar`和`GetCtxVar`来设置和获取自定义的变量，该变量生命周期仅限于当前请求流程。 

 `SetCtx`方法常用于中间件中整合一些第三方的组件，例如第三方的链路跟踪组件等等。 

```go
package main

import (
	"context"
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/net/ghttp"
)

const (
	TraceIdName = "trace-id"
)

func main() {
	s := g.Server()
	s.Group("/", func(group *ghttp.RouterGroup) {
		group.Middleware(func(r *ghttp.Request) {
			ctx := context.WithValue(r.Context(), TraceIdName, "HBm876TFCde435Tgf")
			r.SetCtx(ctx)
			r.Middleware.Next()
		})
		group.ALL("/", func(r *ghttp.Request) {
			r.Response.Write(r.Context().Value(TraceIdName))
			// 也可以使用
			// r.Response.Write(r.GetCtxVar(TraceIdName))
		})
	})
	s.SetPort(8199)
	s.Run()
}
```

