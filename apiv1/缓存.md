# 缓存管理

​		gcache是提供统一的缓存管理模块，提供了开发者可自定义灵活接入的缓存适配接口，并默认提供了高速内存缓存适配实现。

**简要介绍：**

- gcache默认提供默认的高速内存缓存对象，可以通过包方法操作内存缓存，也可以通过New方法创建内存缓存对象。在通过包方法使用缓存功能时，操作的是gcache默认提供的一个gcache.Cache对象，具有全局性，因此在使用时注意全局键名的覆盖。


- gcache使用的键名类型是interface{}，而不是string类型，这意味着我们可以使用任意类型的变量作为键名，但大多数时候建议使用string或者[]byte作为键名，并且统一键名的数据类型，以便维护。


- gcache存储的键值类型是interface{}，也就是说可以存储任意的数据类型，当获取数据时返回的也是interface{}类型，若需要转换为其他的类型可以通过gcache的Get*方法便捷获取常见类型。注意，如果您确定知道自己使用的是内存缓存，那么可以直接使用断言方式对返回的interface{}变量进行类型转换，否则建议通过获取到的泛型对象对应方法完成类型转换。


- 另外需要注意的是，gcache的缓存过期时间参数duration的类型为time.Duration类型，在Set缓存变量时，如果缓存时间参数duration = 0表示不过期，duration < 0表示立即过期，duration > 0表示超时过期。

```go
package main

import (
	"fmt"
	"github.com/gogf/gf/v2/os/gcache"
	"github.com/gogf/gf/v2/os/gctx"
)

func main() {
	type User struct {
		Id   int
		Name string
		Site string
	}
	var (
		ctx   = gctx.New()
		user  *User
		key   = `UserKey`
		value = &User{
			Id:   1,
			Name: "GoFrame",
			Site: "https://goframe.org",
		}
	)
	err := gcache.Set(ctx, key, value, 0)
	if err != nil {
		panic(err)
	}
	v, err := gcache.Get(ctx, key)
	if err != nil {
		panic(err)
	}
	if err = v.Scan(&user); err != nil {
		panic(err)
	}
	fmt.Printf(`%#v`, user)
}
```

结果为

```go
&main.User{Id:1, Name:"GoFrame", Site:"https://goframe.org"}
```

```go
package main

import (
	"fmt"
	"github.com/gogf/gf/v2/os/gcache"
	"github.com/gogf/gf/v2/os/gctx"
	"time"
)

func main() {
	var (
		ctx = gctx.New()
	)
	// 当键名不存在时写入，设置过期时间1000毫秒
	_, err := gcache.SetIfNotExist(ctx, "k1", "v1", time.Second)
	if err != nil {
		panic(err)
	}

	// 打印当前的键名列表
	keys, err := gcache.Keys(ctx)
	if err != nil {
		panic(err)
	}
	fmt.Println(keys)
	
	// 打印当前的键值列表
	values, err := gcache.Values(ctx)
	if err != nil {
		panic(err)
	}
	fmt.Println(values)
	
	// 获取指定键值，如果不存在时写入，并返回键值
	value, err := gcache.GetOrSet(ctx, "k2", "v2", 0)
	if err != nil {
		panic(err)
	}
	fmt.Println(value)
	
	// 打印当前的键值对
	data1, err := gcache.Data(ctx)
	if err != nil {
		panic(err)
	}
	fmt.Println(data1)
	
	// 等待1秒，以便k1:v1自动过期
	time.Sleep(time.Second)
	
	// 再次打印当前的键值对，发现k1:v1已经过期，只剩下k2:v2
	data2, err := gcache.Data(ctx)
	if err != nil {
		panic(err)
	}
	fmt.Println(data2)

}
```

结果为

```json
[k1]
[v1]
v2
map[k1:v1 k2:v2]
map[k2:v2]
```



## 1、接口化设计

​		缓存组件采用了接口化设计，提供了Adapter接口，任何实现了Adapter接口的对象均可注册到缓存管理对象中，使得开发者可以对缓存管理对象进行灵活的自定义实现和扩展。

### 1.1、注册接口实现

通过该方法将实现的adapter应用到对应的Cache对象上：

```go
// SetAdapter changes the adapter for this cache.
// Be very note that, this setting function is not concurrent-safe, which means you should not call
// this setting function concurrently in multiple goroutines.
func (c *Cache) SetAdapter(adapter Adapter)
```

### 1.2、获取接口实现

通过该方法获取当前注册的adapter接口实现对象上：

```go
// GetAdapter returns the adapter that is set in current Cache.
func (c *Cache) GetAdapter() Adapter
```

## 2、Redis缓存

​		缓存组件同时提供了gcache的Redis缓存适配实现。Redis缓存在多节点保证缓存的数据一致性时非常有用，特别是Session共享、数据库查询缓存等场景中。

```go
func ExampleCache_SetAdapter() {
	var (
		err         error
		ctx         = gctx.New()
		cache       = gcache.New()
		redisConfig = &gredis.Config{
			Address: "127.0.0.1:6379",
			Db:      9,
		}
		cacheKey   = `key`
		cacheValue = `value`
	)
	// Create redis client object.
	redis, err := gredis.New(redisConfig)
	if err != nil {
		panic(err)
	}
	// Create redis cache adapter and set it to cache object.
	cache.SetAdapter(gcache.NewAdapterRedis(redis))

	// Set and Get using cache object.
	err = cache.Set(ctx, cacheKey, cacheValue, time.Second)
	if err != nil {
		panic(err)
	}
	fmt.Println(cache.MustGet(ctx, cacheKey).String())
	
	// Get using redis client.
	fmt.Println(redis.MustDo(ctx, "GET", cacheKey).String())
	
	// Output:
	// value
	// value

}
```

