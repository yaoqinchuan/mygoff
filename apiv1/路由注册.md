# **路由注册**

mygofg的路由注册有多重方式，主要有

1. **方法注册**
2. **对象注册**
3. **规范路由注册**

## **1、方法注册**

方法注册可以分为三种方式，使用的方法为

```go
`func (s *Server) BindHandler(pattern string, handler interface{})`
```

1. **匿名函数注册**
2. **有名函数注册**
3. **对象方法注册**

### **1.1 、匿名函数注册**

匿名函数注册指的是使用handler的匿名函数来处理这个请求，如下所示：

```go
package main`

`import (`
    `"github.com/gogf/gf/v2/frame/g"`
    `"github.com/gogf/gf/v2/net/ghttp"`
`)`

`func main() {`
    `s := g.Server()`
    `s.BindHandler("/", func(r *ghttp.Request) {`
        `r.Response.Write("哈喽世界！")`
    `})`
    `s.SetPort(8199)`
    `s.Run()`
`}
```



### **1.2、有名函数注册**

有名函数注册指的是使用有名函数来处理请求，使用的方法如下：

```go
package main`

`import (`
	`"github.com/gogf/gf/v2/container/gtype"`
	`"github.com/gogf/gf/v2/frame/g"`
	`"github.com/gogf/gf/v2/net/ghttp"`
`)`

`var (`
	`total = gtype.NewInt()`
`)`

`func Total(r *ghttp.Request) {`
	`r.Response.Write("total:", total.Add(1))`
`}`

`func main() {`
	`s := g.Server()`
	`s.BindHandler("/total", Total)`
	`s.SetPort(8199)`
	`s.Run()`
`}
```



### **1.3、对象方法注册**

该注册方法需要使用一个实例化的对象，并且指定该对象的方法进行注册，如下所示：

```GO
package main`

`import (`
	`"github.com/gogf/gf/v2/container/gtype"`
	`"github.com/gogf/gf/v2/frame/g"`
	`"github.com/gogf/gf/v2/net/ghttp"`
`)`

`type Controller struct {`
	`total *gtype.Int`
`}`

`func (c *Controller) Total(r *ghttp.Request) {`
	`r.Response.Write("total:", c.total.Add(1))`
`}`

`func main() {`
	`s := g.Server()`
	`c := &Controller{`
		`total: gtype.NewInt(),`
	`}`
	`s.BindHandler("/total", c.Total)`
	`s.SetPort(8199)`
	`s.Run()`
`}
```



## **2、对象注册**

直接使用对象来进行注册，他的uri会和对象的方法名称相关联，使用的方法为

```go
`func (s *Server) BindObject(pattern string, object interface{}, methods ...string) error`
`func (s *Server) BindObjectMethod(pattern string, object interface{}, method string) error`
`func (s *Server) BindObjectRest(pattern string, object interface{}) error`
```



### **2.1、一般对象注册**

 可以看到，对象在进行路由注册时便生成了一个对象（对象在`Server`启动时便生成），此后不管多少请求进入，`Server`都是将请求转交给该对象对应的方法进行处理。需要注意的是，公开方法的定义 ，并且访问的uri会拼接上方法的名称，在这里为`/object/show`与`/object/index` 

```go
package main`

`import (`
	`"github.com/gogf/gf/v2/frame/g"`
	`"github.com/gogf/gf/v2/net/ghttp"`
`)`

`type Controller struct{}`

`func (c *Controller) Index(r *ghttp.Request) {`
	`r.Response.Write("index")`
`}`

`func (c *Controller) Show(r *ghttp.Request) {`
	`r.Response.Write("show")`
`}`

`func main() {`
	`s := g.Server()`
	`c := new(Controller)`
	`s.BindObject("/object", c)`
	`s.SetPort(8199)`
	`s.Run()`
`}
```



#### **2.1.1、命名风格规则**

通过对象进行路由注册时，可以根据对象及方法名称自动生成路由规则，默认的路由规则为：当方法名称带有多个`单词`（按照字符大写区分单词）时，路由控制器默认会自动使用英文连接符号`-`进行拼接，因此访问的时候方法名称需要带`-`号。

例如，方法名为`UserName`时，生成的路由为`user-name`；方法名为`ShowListItems`时，生成的路由为`show-list-items`；以此类推。

此外，我们可以通过`.Server.SetNameToUriType`方法来设置对象方法名称的路由生成方式。支持的方式目前有`4`种，对应`4`个常量定义：

```go
`UriTypeDefault  = 0 // （默认）全部转为小写，单词以'-'连接符号连接`
`UriTypeFuleName = 1 // 不处理名称，以原有名称构建成URI`
`UriTypeAllLower = 2 // 仅转为小写，单词间不使用连接符号`
`UriTypeCamel    = 3 // 采用驼峰命名方式`
```



```go
package main

import (
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/net/ghttp"
)

type User struct{}

func (u *User) ShowList(r *ghttp.Request) {
	r.Response.Write("list")
}

func main() {
	u := new(User)
	s1 := g.Server("UriTypeDefault")
	s2 := g.Server("UriTypeFullName")
	s3 := g.Server("UriTypeAllLower")
	s4 := g.Server("UriTypeCamel")
    s1.SetNameToUriType(ghttp.UriTypeDefault)
    s2.SetNameToUriType(ghttp.UriTypeFullName)
    s3.SetNameToUriType(ghttp.UriTypeAllLower)
    s4.SetNameToUriType(ghttp.UriTypeCamel)

    s1.BindObject("/{.struct}/{.method}", u)
    s2.BindObject("/{.struct}/{.method}", u)
    s3.BindObject("/{.struct}/{.method}", u)
    s4.BindObject("/{.struct}/{.method}", u)

    s1.SetPort(8100)
    s2.SetPort(8200)
    s3.SetPort(8300)
    s4.SetPort(8400)

    s1.Start()
    s2.Start()
    s3.Start()
    s4.Start()
    g.Wait()
}
```
#### 2.1.2、路由内置变量

 当使用`BindObject`方法进行对象注册时，在路由规则中可以使用两个内置的变量：`{.struct}`和`{.method}`，前者表示当前**对象名称**，后者表示当前注册的**方法名** 。

```go
package main`

`import (`
	`"github.com/gogf/gf/v2/frame/g"`
	`"github.com/gogf/gf/v2/net/ghttp"`
`)`

`type Order struct{}`

`func (o *Order) List(r *ghttp.Request) {`
	`r.Response.Write("list")`
`}`

`func main() {`
    `s := g.Server()`
    `o := new(Order)`
	`s.BindObject("/{.struct}-{.method}", o)`
	`s.SetPort(8199)`
	`s.Run()`
`}
```

![](C:\Users\yqc\AppData\Roaming\Typora\typora-user-images\1643795829935.png)

### 2.2、对象方法注册

 假如控制器中有若干公开方法，但是我只想注册其中几个，其余的方法我不想对外公开，怎么办？我们可以通过`BindObject`传递**第三个非必需参数**替换实现，参数支持传入**多个**方法名称，多个名称以英文`,`号分隔（**方法名称参数区分大小写**）。 

```go
package main

import (
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/net/ghttp"
)

type Controller struct{}

func (c *Controller) Index(r *ghttp.Request) {
	r.Response.Write("index")
}

func (c *Controller) Show(r *ghttp.Request) {
	r.Response.Write("show")
}

func main() {
	s := g.Server()
	c := new(Controller)
	s.BindObject("/object", c, "Show")
	s.SetPort(8199)
	s.Run()
}
```

### 2.3、绑定路由方法

 我们可以通过`BindObjectMethod`方法绑定指定的路由到指定的方法执行（**方法名称参数区分大小写**）。 

```go
package main

import (
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/net/ghttp"
)

type Controller struct{}

func (c *Controller) Index(r *ghttp.Request) {
	r.Response.Write("index")
}

func (c *Controller) Show(r *ghttp.Request) {
	r.Response.Write("show")
}

func main() {
	s := g.Server()
	c := new(Controller)
	s.BindObjectMethod("/show", c, "Show")
	s.SetPort(8199)
	s.Run()
}
```

### 2.4、Restful 对象注册

 我们可以通过`BindObjectRest`方法完成`REST`对象的注册，示例： 

```go
package main

import (
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/net/ghttp"
)

type Controller struct{}

// RESTFul - GET
func (c *Controller) Get(r *ghttp.Request) {
	r.Response.Write("GET")
}

// RESTFul - POST
func (c *Controller) Post(r *ghttp.Request) {
	r.Response.Write("POST")
}

// RESTFul - DELETE
func (c *Controller) Delete(r *ghttp.Request) {
	r.Response.Write("DELETE")
}

// 该方法无法映射，将会无法访问到
func (c *Controller) Hello(r *ghttp.Request) {
	r.Response.Write("Hello")
}

func main() {
	s := g.Server()
	c := new(Controller)
	s.BindObjectRest("/object", c)
	s.SetPort(8199)
	s.Run()
}
```

## 3、构造方法`Init`与析构方法`Shut`

对象中的`Init`和`Shut`是两个在`HTTP`请求流程中被`Server`自动调用的特殊方法（类似`构造函数`和`析构函数`的作用）。

### 3.1、Init回调方法

对象收到请求时的初始化方法，在服务接口调用之前被回调执行。

方法定义：

```go
// "构造函数"对象方法
func (c *Controller) Init(r *ghttp.Request) {
}
```

### 3.2、Shut回调方法

当请求结束时被`Server`自动调用，可以用于对象执行一些收尾处理的操作。

方法定义：

```go
// "析构函数"对象方法
func (c *Controller) Shut(r *ghttp.Request) {
}
```

## 4、规范路由注册

### 4.1、配置文件

这里使用`YAML`配置文件：`config.yaml`

```yaml
server:
  address:     ":8199"
  openapiPath: "/api.json"
  swaggerPath: "/swagger"
```

### 4.2、示例代码

```go
package apiv1

import (
	"context"
	"fmt"
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/net/ghttp"
	"mygogf/internal/utils"
)

type HelloReq struct {
	g.Meta `path:"/hello" tags:"Hello" method:"get" summary:"You first hello api"`
	Name   string `v:"required" dc:"your name"`
}
type HelloRes struct {
	Reply string `dc:"replay content"`
}
type Hello struct {
}

func (hello *Hello) Say(ctx context.Context, req *HelloReq) (res *HelloRes, err error) {
	utils.PrintLog(ctx, utils.INFO, fmt.Sprintf(`receive say: %v`, req))
	res = &HelloRes{Reply: fmt.Sprintf(`Hi %s`, req.Name)}
	return
}

func RegisterHelloController(ctx context.Context, server *ghttp.Server) {
	var hello = Hello{}
	server.BindObject("/hello", hello, "Say")
}
```

#### 4.2.1、路由方法定义

 路由方法定义使用固定的格式： 

```go
func Handler(ctx context.Context, req *Request) (res *Response, err error)
```

 其中输入参数和输出参数都是两个，并且都是必须的一个都不能少。简单介绍下： 

| 参数                |   说明   | 注意事项                                                     |
| :------------------ | :------: | ------------------------------------------------------------ |
| ctx context.Context |  上下文  | `Server`组件会自动从请求中获取并传递给接口方法               |
| err error           | 错误对象 | `Server`通过该参数判断接口执行成功或失败。                   |
| req *Request        | 请求对象 | 就算没有接收参数也要定义，因为请求结构体中不仅仅包含请求参数的定义，也包含了接口的请求定义。 |
| res *Response       | 返回对象 | 就算没有返回参数也要定义，因为返回结构体中不仅仅包含返回参数的定义，也可以包含接口返回定义。 |

#### 4.2.2、请求/返回结构体

 在规范化路由注册中，非常重要的是请求/返回结构体的定义，在该结构体不仅仅包含了输入参数的定义，也包含了接口的定义，特别是路由地址、请求方法、接口描述等信息。为保证命名规范化，输入数据结构以`XxxReq`方式命名，输出数据结构以`XxxRes`方式命名。即便输入或者输出参数为空，也需要定义相应的数据结构，这样的目的一个是便于后续扩展，另一个是便于接口信息的管理。 

请求参数自动转换到请求数据结构，字段映射转换不区分大小写，也会自动忽略特殊字符。 

**请求结构体在进入API接口执行前将会被自动执行校验**，如果其中一条规则校验失败，那么将终止后续规则的校验。校验功能使用的是框架统一的校验组件 。

 接口的数据返回处理需要设置统一的后置中间件，当然也可以使用`Server`默认提供的数据返回中间件。开发者自定义中间件时可以参考`Server`默认提供的中间件。注意其中的一个重要的方法：

```go
// GetHandlerResponse retrieves and returns the handler response object and its error.
func (r *Request) GetHandlerResponse() (res interface{}, err error) 
```

 通过后置中间件执行时通过请求对象的`GetHandlerResponse`方法获取当前业务执行的结果，并根据需要做相应处理。 

## 5、`OpenAPIv3`协议

Server组件自动生成的接口文档使用的是最新的`OpenAPIv3`协议。

### 5.1、元数据信息

接口的元数据信息可以通过为输入结构体 `embedded` 方式嵌入 `g.Meta` 结构，并通过 `g.Meta` 的属性标签方式来实现。

### 5.2、自动支持`OpenAPIv3`的属性标签

输入输出结构体中的属性的标签完整支持`OpenAPIv3`协议，因此只要增加了对应的协议标签，那么生成的`OpenAPIv3`接口信息中将会自动包含该属性。

大部分的标签属性已经被Server组件自动生成，开发者需要手动设置的标签不多。常见的标签包括：

| 标签        | 说明                                                   | 备注                       |
| ----------- | ------------------------------------------------------ | -------------------------- |
| tags        | 接口所属的标签，用于接口分类                           | 用于`g.Meta`标识接口元数据 |
| summary     | 接口/参数概要描述                                      | 缩写`sum`                  |
| path        | 结合注册时的前缀共同构成接口URI路径                    | 用于`g.Meta`标识接口元数据 |
| method      | 接口的请求方式：`GET/PUT/POST/DELETE...(不区分大小写)` | 用于`g.Meta`标识接口元数据 |
| in          | 参数的提交方式                                         | header/path/query/cookie   |
| description | 接口/参数详细描述                                      | 缩写`dc`                   |
| deprecated  | 标记该接口废弃                                         | 用于`g.Meta`标识接口元数据 |
| default     | 参数的默认值                                           | 缩写`d`                    |

 更多的`OpenAPIv3`标签请参考：https://swagger.io/specification/ 

### 5.3、扩展`OpenAPIv3`信息

核心的接口信息已经自动生成，如果开发者想要更进一步完善接口信息，可以通过`s.GetOpenApi()`接口获取到`OpenAPIv3`的结构体对象，并手动填充对应的属性内容即可。我们来看一个示例，在该示例中，我们将接口中的标签进行了自定义的排序，并且增加了对每个标签的详细描述：

 ![image2021-11-20_0-36-7.png](https://goframe.org/download/attachments/30736904/image2021-11-20_0-36-7.png?version=1&modificationDate=1637339655388&api=v2) 

自己还没试过，做一个TODO吧